# python list
x = [1, 2, 3, 4, 5]
print(x * 2)
# print(x + 10) # can only concatenate list (not "int") to list
y = [10, 20, 30]
print(x + y)  # [1, 2, 3, 4, 5, 10, 20, 30]

# Numpy arrays
import numpy as np

ax = np.array([1, 2, 3, 4])
print(ax * 2)  # [ 2  4  6  8]
print(ax + 10)  # [11 12 13 14]

ay = np.array([5, 6, 7, 8])
print(ax + ay)  # [ 6  8 10 12]

print(ax * ay)  # [ 5 12 21 32]


# 计算多项式的值
def f(x):
    return 3 * x ** 2 - 2 * x + 7


print(f(ax))  # [ 8 15 28 47]

# numpy内置方法
print(np.sqrt(ax))  # [1.         1.41421356 1.73205081 2.        ]

print(np.cos(ax))  # [ 0.54030231 -0.41614684 -0.9899925  -0.65364362]

# 使用 NumPy 中的通用函数，其效率要比对数组进行迭代然后使用 math 模块中的函数 每次只处理一个元素快上百倍
# 在底层，NumPy 数组的内存分配方式和 C 或者 Fortran 一样。即，它们是大块的连续内 存，由同一种类型的数据组成。正是因为这样，NumPy 才能创建比通常 Python 中的列 表要大得多的数组。

# 二维数组
grid = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(grid)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# 行
print(grid[1])  # [4 5 6]
# 列
print(grid[:, 2])  # [3 6 9]
# 指定位置
print(grid[1, 2])  # 6

# 子矩阵
print(grid[1:3, 1:3])
# [[5 6]
#  [8 9]]

# 修改
print(grid[1:3, 1:3] + 1)
# [[ 1  2  3]
#  [ 4  6  7]
#  [ 7  9 10]]

# 对应列增加
print(grid + [100, 101, 102])
# [[101 103 105]
#  [104 106 108]
#  [107 109 111]]

# 对应行增加
print(grid + [[100], [101], [102]])
# [[101 102 103]
#  [105 106 107]
#  [109 110 111]]

# grid < 5是一个条件表达式，它会对grid数组中的每个元素进行比较，判断是否小于5。
# 如果条件满足（即元素小于5），则返回grid数组中对应位置的元素。
# 如果条件不满足（即元素大于等于5），则返回值为10。
print(np.where(grid < 5, grid, 10))
# [[ 1  2  3]
#  [ 4 10 10]
#  [10 10 10]]

# 数组的形状
print(grid.shape)  # (3, 3)

big_grid = np.zeros(shape=(1000, 1000), dtype=float)
print(big_grid)
# [[0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  ...
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]]

big_grid += 10
print(big_grid)
# [[10. 10. 10.... 10. 10. 10.]
